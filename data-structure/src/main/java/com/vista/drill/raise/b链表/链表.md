链表
解题：多画图
解题技巧：虚拟头结点、快慢指针、多指针
常见代码要非常熟练：链表节点的插入、删除；反转链表；快慢指针求中心节点

https://juejin.im/post/6844904118394290190

1.移除链表元素
  删除链表中等于给定值val的所有节点。要求：时间复杂度 O(n), 空间复杂度 O(1)
设置3个指针：
head：扫描链表节点
newHead：虚拟头结点（新链表的头结点）
newTail：新链表的尾结点
初始状态： newHead=newTail=new Node(0)
返回结果：newHead.next

* 建立新链表的虚拟头结点 newHead=newTail=new Node(0)
* 遍历链表节点 head=head.next
* 若节点不等于被删除的节点值，则newTail.next指向当前结点： newTail.next=head;
  newTail前移一位指向当前结点： newTail=head；当前结点指向下一个节点： head=head.next
* 直至遍历到链表的null节点为止
* newTail指针指向null ： newTail.next=null
* 返回新链表的首个节点： newHead.next


2.两数相加
  2个非空链表标识连个2个非负的正数。各自位数按照逆序方式存储，并且一个节点仅存储一位数字。
  将两个数相加，返回一个新的链表表示它们的和

设置2个指针、1个变量：
dummyHead:新链表的虚拟头结点
last：新链表的尾结点
carry：进位值
l1、l2：遍历两个链表
初始状态：dummyHead=last=new Node(0)
状态转移方程：
- 遍历两个链表，将两个节点值与进位值相加；
- 创建新节点存储个位值，十位值存储在carray中
- 新链表添加新节点:last.next=newNode(..) ;last指向新节点
- 若两链表中有一个结点为null，视为0
- 若两链表结点均为null时，先判断是否有进位(若存在，创建新结点存储进位值，并将结点加入到链表中)，然后退出

返回结果：dummyHead.next


3.相交链表
找出两个链表相交的起始节点，要求： O(n) 时间复杂度，且仅用 O(1) 内存。
注意：
如果两个链表没有交点，返回 null.
在返回结果后，两个链表仍须保持原有的结构。
可假定整个链表结构中没有循环。

思路：（两个链表分别加上另一个链表，使得总长度相同，最后部分即为相同部分）
- 遍历两个链表，判断两节点元素是否相同
- 若一个链表下一个节点为null，则循环另一个链表
- 直至查找到相同节点，或两节点都为null


4.分割两个链表
给定一个链表和一个特定值x，对链表进行分割，使得所有小于x的结点都在左边，所有大于等于x的结点都在右边。
要求： 保留结点最初的相对位置，O(n) 时间复杂度，且仅用 O(1) 内存。

设置两个新链表 a b，分别设定2个指针：虚拟头节点，尾指针
- 遍历目标链表
- 若节点小于x，节点加入a链表，a链表尾指针指向当前结点
- 若节点大于等于x，结点加入b链表，b链表指针指向当前结点
- 遍历完成后，a链表尾结点与b链表首个节点拼接在一起
- 设置b链表尾结点 next 为null，返回a链表首个节点





  
  






