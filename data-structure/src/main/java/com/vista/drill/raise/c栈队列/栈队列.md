栈、队列、双端队列
栈：先进后出
    解决对称：判断回文链表（找到中间结点，左半部分入栈，元素依次出栈域右半部分元素比较）
队列：先进先出
双端队列：可在头尾两端进行添加、删除的队列

1.最小栈
设计一个push(入栈)、pop(出栈)、top(查询栈顶元素)操作，并能在常数时间内检索最小元素的栈
push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。

方法1： 创建2个栈
- 正常栈 stack：正常存放数据
- 最小栈 minStack： 存放最小数据
minStack.top:即为当前stack元素中最小元素
stack.push(x)添加元素时，minStack同时添加当前stack中到x元素时的最小数据：minStack.push(Math.min(minStack.top,x))
stack.pop()删除元素时，minStack同时pop()操作



方法2：底层利用链表存储元素
Node{int val ; int min ; Node next}
思路：结点node同时存储数据及当前数据最小值（原理与栈相同，仅是底层实现不同）


2.滑动窗口最大值
给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
返回滑动窗口中的最大值。
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 
  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7

方法1： 双端队列
- 双端队列：存放索引。队列元素从头到尾对应的元素值递减
思路：设置2个指针
- w:窗口头部（注意有效值）
- i:遍历元素，即滑动窗口最后一个元素指针[0,nums.lenth)-> 注意有效值
- 如果nums[i]>=队尾，不断删除队尾，直到 队尾>nums[i] 为止，nums[i]入队
- 检查队头是否过期(有效)，过期则移除，设置w窗口最大值为nums[队头]
注：若每次只移动一位，则队列中过期的队头，只可能有一个


方法2：暴力法



3.最大二叉树
给定一个不含重复元素的整数数组，将数组构建成一个最大二叉树
根：数组中最大元素
左子树：数组最大值左边部分构造出的最大二叉树
右子树：数组最大值右边部分构造出的最大二叉树
通过给定的数组构建最大二叉树，并输出这个树的根结点

思路：递归实现
给定一个方法，通过该方法找到指定范围内的最大元素，并将其创建为根结点，然后递归调用该方法，分别找到根结点的左子节点、右子节点，返回根结点

3.1 最大二叉树-延伸
返回一个数组，数组里面存着每个结点的父节点的索引，若没有父节点，返回-1
结点的父节点的特点：左右两边第一个比它大的值的最小值
思路： 创建两个数组 nums1、nums2，
- nums1:存储每个结点左边第一个比它大的值
- nums2:存储每个结点右边第一个比它大的值
nums1、nums2两者中相对较小值，即为该结点的父节点

实现：创建一个栈
- 栈：栈底->栈顶 单调递减
- 将数组元素单调递减的存入栈中
- 如果值a，满足单调递减的条件，则入栈，栈顶元素是该值a的左边第一个比它大的元素
- 如果值a，不满足单调递减条件，则弹出栈顶元素，弹出元素右边第一个比它大的元素即为值a；






















