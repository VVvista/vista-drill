串：

1.字符串轮转
字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。

示例1:
 输入：s1 = "waterbottle", s2 = "erbottlewat"
 输出：True
 
思路：利用旋转的特性，两个s1串首尾拼接，则s2一定是s1+s1的子串
- s1+s1="waterbottlewaterbottle"
- s2="erbottlewat"
总结：
* s1的任何旋转串都是s1+s1的子串
* s1与s2的长度必须相同
注意：判断一个串是否为另一个串的子串，可以直接调用contains(),或使用kmp算法

2.另一个树的子树
给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。
s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。

链接：https://leetcode-cn.com/problems/subtree-of-another-tree

思路：将树s、t序列化输出，判断t串是否为s的子串
- 前序/后序遍历s、t，将其序列化为字符串
- 判断t串是否为s的子串
注意：
1.序列化后为了区分 '结点12' 与 '结点1、结点2',每个结点后添加特殊字符'!'
2.序列化后为了能唯一确定一棵树，结点的空子节点使用'#!'代替，并序列化打印
3.若使用前序遍历，序列化串头部加上'!'，避免 '12!#!#!' 与 '2!#!#!' 的特殊情况


3.有效的字母异位词
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
输入: s = "anagram", t = "nagaram"
输出: true
说明：你可以假设字符串只包含小写字母。

思路：
创建一个数组分别存储a-z字符出现的次数
- 循环遍历s字符，并在数组对应位置+1
- 循环遍历t字符，在数组的对应位置-1，若数组元素<0，则退出，两字符串不相等


4.d_翻转字符串里的单词
给定一个字符串，逐个翻转字符串中的每个单词。
说明：
无空格字符构成一个 单词 。
输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

链接：https://leetcode-cn.com/problems/reverse-words-in-a-string
要求：删除字符串两端的空格，删减两个单词间多余的空格(2单词间仅一个空格)

思路：
- 删除字符串两端及中间多余空格： 循环遍历字符，将符合要求字符往前移
    设置两个指针： i 循环遍历字符  cur 截止当前可以放字符的地方
    设置一个变量：space 前一个字符是否为空字符
- 对字符串逆序
- 对每个单词逆序：
    设置两个指针，分别指向单词首尾处的空格位置


