####递归

* 如果递归调用没有终止，将会一直消耗栈空间，最终导致栈内存溢出
* 因此必须有一个明确的结束递归的条件，也叫作边界条件、递归基

实例：
1.求1+2+3+...+n的和(n>0)
递归：时间复杂度：O(n)，空间复杂度：O(n)
循环：时间复杂度：O(n)，空间复杂度：O(1)
公式：时间复杂度：O(1)，空间复杂度：O(1)

注：使用递归不是为了求得最优解，是为了简化解决问题的思路，代码更加简洁
递归求出来的很有可能不是最优解，也有可能是最优解

#####递归的基本思想
1.拆解问题：
* 把规模大的问题变成规模较小的同类型问题
* 规模较小的问题又不断变成规模更小的问题
* 规模小到一定程度可以直接得到它的解

2.求解：
* 由小规模问题的解得出较大规模的解
* 由较大规模问题的解不断得出规模更大问题的解

很多链表、二叉树相关的问题都可以使用递归解决（因为其结构本身就是递归的）


#####递归的使用套路
1.明确函数的功能
  先不要去思考里面代码怎么写，首先搞清楚这个函数是干嘛用的，能实现什么功能
2.明确原问题与子问题的关系
  寻找f(n)与f(n-1)的关系
3.明确递归基(边界条件)
  寻找递归基，相当于思考：问题规模小到什么程度可以直接得出解
  
  
#####练习
1.斐波那契数列
1 1 2 3 5 8 13 21 34 ...
f(1)=1,f(2)=1,f(n)=f(n-1)+f(n-2)(n>=3)
由T(n)=T(n-1)+T(n-2)+O(1) =>时间复杂度：O(2^n)，有很多的重复计算
空间复杂度：O(n)
递归调用的空间复杂度=递归深度* 每次调用所需的辅助空间(只要求出递归占用的栈最大空间即可，其他仅是重复利用该栈空间)






 





