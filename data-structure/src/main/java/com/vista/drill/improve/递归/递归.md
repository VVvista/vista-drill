####1.递归
函数(方法)直接或间接掉调用自身，是一种编程技巧
函数的调用过程：栈空间会将调用的函数一次入栈，如果函数被调用但是没有任何操作将会被忽视，调用完成后释放
* 如果递归调用没有终止，将会一直消耗栈空间，最终导致栈内存溢出
* 因此必须有一个明确的结束递归的条件，也叫作边界条件、递归基

实例：
1.求1+2+3+...+n的和(n>0)
递归：时间复杂度：O(n)，空间复杂度：O(n)
循环：时间复杂度：O(n)，空间复杂度：O(1)
公式：时间复杂度：O(1)，空间复杂度：O(1)

注：使用递归不是为了求得最优解，是为了简化解决问题的思路，代码更加简洁
递归求出来的很有可能不是最优解，也有可能是最优解

#####递归的基本思想
1.拆解问题：
* 把规模大的问题变成规模较小的同类型问题
* 规模较小的问题又不断变成规模更小的问题
* 规模小到一定程度可以直接得到它的解

2.求解：
* 由小规模问题的解得出较大规模的解
* 由较大规模问题的解不断得出规模更大问题的解

很多链表、二叉树相关的问题都可以使用递归解决（因为其结构本身就是递归的）


#####递归的使用套路
1.明确函数的功能
  先不要去思考里面代码怎么写，首先搞清楚这个函数是干嘛用的，能实现什么功能
2.明确原问题与子问题的关系
  寻找f(n)与f(n-1)的关系
3.明确递归基(边界条件)
  寻找递归基，相当于思考：问题规模小到什么程度可以直接得出解
  
  
#####练习
1.斐波那契数列
1 1 2 3 5 8 13 21 34 ...
f(1)=1,f(2)=1,f(n)=f(n-1)+f(n-2)(n>=3)
由T(n)=T(n-1)+T(n-2)+O(1) =>时间复杂度：O(2^n)，有很多的重复计算
空间复杂度：O(n)
递归调用的空间复杂度=递归深度 * 每次调用所需的辅助空间(只要求出递归占用的栈最大空间即可，其他仅是重复利用该栈空间)
优化：循环 公式 数组 长度为2的数组

2.上楼梯(跳台阶)
楼梯有n阶台阶，上楼可以一步上一阶，也可以一步上2阶，走完n阶台阶共有多少种不同的走法
f(1)=1,f(2)=2,f(n)=f(n-1)+f(n-2)(n>=3)
时间复杂度：O(2^n)，有很多的重复计算，空间复杂度：O(n)
优化同：斐波那契数列

3.汉诺塔(Hanoi)
将a中的n个盘子挪动到c中：每次只挪动1个盘子，大盘子必须在小盘子下面
当n=1时，直接将盘子从a挪动c；
当n>1时，将n-1个盘子从a挪动到b；将编号n的盘子从a挪动到c；将n-1个盘子从b挪动到c
由T(n)=T(n-1)+T(n-1)+O(1) =>时间复杂度：O(2^n)，空间复杂度：O(n)

#####递归转非递归
递归调用的过程中，会将每一次调用的参数、局部变量都保存在对应的栈帧中。
* 若递归调用深度较大，会占用比较多的栈空间，甚至会导致栈溢出
* 有些时候，递归会存在大量的重复计算，性能比较差
* 递归能完全转换成非递归

万能方法：
* 自己维护一个栈来保存参数、局部变量，但是空间复杂度依然没有得到优化
* 重复使用同一变量来保存每个栈帧内的参数

####2.尾调用
尾调用：一个函数的最后一个动作是调用函数
如果最后一个动作是调用自身，称为尾递归，是尾调用的特殊情况
一些编译器能对尾调用进行优化，以达到节省栈空间的目的.(java的jvm虚拟机无此特性)

非尾调用：
```
int factorial(int n) {
	if (n <= 1) return n;
	return n * factorial(n - 1);// 因为它最后一个动作是乘法，没有调用自身
}
```

#####尾调用优化
尾调用优化也称为：尾调用消除
  如果当前栈帧上的局部变量等内容都不需要用了，当前栈帧经过适当的改变后可以直接当作被尾调用的函数的栈帧使用，然后程序可以使用jump到被尾调用的函数代码，无需再为尾调用函数开辟新的栈空间

消除尾递归里的尾调用比消除一般的尾调用容易
  例如：java虚拟机会消除尾递归里的尾调用，但不会消除一般的尾调用(因为改变不了栈帧)
  因此尾递归优化相对比较普遍，平时的递归代码可以考虑尽量使用尾递归的方式。
  
尾调用优化：降低了空间复杂度


参考：https://blog.csdn.net/weixin_43734095/article/details/105532299