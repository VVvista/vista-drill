原型模式：通过现有对象创建出一个或多个新对象
定义：不通过创建new 关键字创建一个新对象，而是通过对一个已创建对象的拷贝创建新对象，并且使新对象与原对象具有相同的特征属性。


new 对象的缺点：
1.对象的初始化消耗较多资源
2.构造函数需要传递过多的属性
3.使用for循环拷贝对象时创建大量的临时变量


原型模式的实现方式：
0.简单拷贝：
  1.抽象原型(Prototype)：规定拷贝接口，具体原型（Concrete Prototype）继承抽象原型，重写拷贝接口：利用new 创建新对象并进行赋值。
1.浅拷贝原型模式：
  1.具体原型类实现Cloneable接口，具体实现clone()方法处理逻辑：直接调用super.clone实现的是浅拷贝
2.深拷贝原型模式：
  1.具体原型类实现Cloneable接口，具体实现clone()方法处理逻辑：利用super.clone拷贝的新对象，对新对象的引用属性再进行深拷贝赋值。（引用属性类也需要同样操作）
  2.具体原型类实现Serializable接口（引用属性对象类也需要实现Serializable接口），使用二进制流写入内存，然后再读取出来，得到一个新对象


原型模式的优点：
  1.性能优良，Java 自带的原型模式 是基于内存二进制流的拷贝，比直接 new 一个对象性能上提升了许多。
  2.可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用(例如恢复到历史某一状态)，可辅助实现撤销操作
原型模式的缺点：
  1.每一个类必须配备一个克隆（或者可拷贝）方法。
  2.克隆方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违反了开闭原则
  3.对克隆复杂对象或对克隆出的对象进行复杂改造时，易带来风险。
  4.在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深拷贝、浅拷贝需要运用得当。
  5.原型模式可能导致单例模式失效，为了保持单例:clone(){return this;}
原型模式的特点：
  1.不调用构造函数。

参考：https://blog.csdn.net/little__superman/java/article/details/104759442




 
 