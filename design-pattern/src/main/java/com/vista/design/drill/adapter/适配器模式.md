适配器模式
将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作。
通过创建适配器解决接口不兼容的问题。

依据适配器类与是适配者类之间的关系，可以分为类适配器、对象适配器


类适配器：适配器与适配者之间是继承/实现关系，将适配器转换成了适配者
 * 1.创建抽象类、具体类：提供并实现对外的公共方法
 * 2.创建客户端类：添加抽象类引用，提供对外访问方法：底层调用抽象类对象的方法
 * 3.创建适配者接口、适配者类：提供并实现对外的公共方法
 * 4.创建适配器类：继承适配者类，实现抽象类，实现抽象类方法：底层调用适配器类方法
适配器即是抽象类的子类，也是适配者的子类，在重写抽象类方法时，底层真正调用的是适配者的方法

对象适配器：适配器与适配者是组合关系，适配器中添加适配者的引用
 * 1.创建抽象类、具体类：提供并实现对外的公共方法
 * 2.创建客户端类：添加抽象类引用，提供对外访问方法：底层调用抽象类对象的方法
 * 3.创建适配者接口、适配者类：提供并实现对外的公共方法
 * 4.创建适配器类：实现抽象类，添加适配者类引用，实现抽象类方法：底层调用适配器类方法
适配器是抽象类的子类，添加适配者引用，在重写抽象类方法时，底层真正调用的是适配者引用的方法

角色：
* 目标类 target：目标接口或类，客户端调用的接口或类（即DBSocket）
* 适配器类 adapter：实现目标类，实现目标类的方法：底层调用适配者的方法
* 适配者类 adaptee：适配器方法中调用的真正主体，实际需要被适配的对象类。


适配器的特点：
1.适配器对象必须实现抽象类接口
2.适配器组合一个适配者对象引用
3.适配器实现抽象类方法，底层调用适配者对象方法


优点：
1.将抽象类与适配者类进行解耦，使适配者方法适应抽象类的方法接口
2.添加了类的适配性和复用性，可以在不同子系统中调用
3.增加了灵活性和扩展性，抽象类的改动不影响适配者的代码。实现了开闭原则


使用场景：
    系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。
    想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。

参考：https://blog.csdn.net/zhangjg_blog/article/details/18735243?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3



















